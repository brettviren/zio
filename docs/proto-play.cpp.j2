/*
 * THIS FILE IS TOTALLY GENERATED.  DO NOT EDIT
 */

#ifndef {{namespace|upper}}_{{classname|upper}}_HPP_SEEN
#define {{namespace|upper}}_{{classname|upper}}_HPP_SEEN

namespace {{namespace}} {

    class APIBase {
      public:

        zmq::message_t to_message(const json& obj)
        {
            std::vector<std::uint8_t> dat = json::to_msgpack(obj);
            return zmq::multipart_t mm(dat.data(), dat.size());
        }
        json to_object(const zmq::message_t& msg)
        {
            const std::vector<const std::uint8_t> vdat(msg.data<std::uint8_t>(),
                                                       msg.size());
            return json::from_msgpack(vdat);    
        }
        void send_command(const json& obj) {
            auto msg = to_message(obj);
            auto res = m_cmdpipe.send(msg, zmq::send_flags::none);
        }
        json recv_reply() {
            zmq::message msg;
            auto res = m_cmdpipe.recv(msg, zmq::recv_flags::none);
            return to_object(msg);
        }
        
    };
    
class {{classname}} : public APIBase {
  public:
    {% for met in methods %}
    /// {{met.help}}
    {{ met.type.c }} {{ met.message.name }} ( {% for f in met.message.attrs %}{{f.type.c}} {{f.name}} {{ "," if not loop.last }} {%endfor%});
    {% endfor %}
};

}

{% for met in methods %}
// {{met.help}}
{{ met.type.c }} {{namespace}}::{{classname}}::{{ met.message.name }} ( {% for f in met.message.attrs %}{{f.type.c}} {{f.name}}{{ "," if not loop.last }} {%endfor%})
{
    send_command({
            {"name","{{met.message.name}}"},
            {% for f in met.message.attrs -%}
            { "{{f.name}}", {{f.name}} },
            {%-endfor%}
        });

    {% if met.accepts %}
    auto obj = recv_command();
    {% if met.type.c != "void" %}

    {% for acc in met.accepts %}
    if (obj["name"] == "{{acc.message.name}}") {
        {% for err in acc.errors %}
        if (obj["{{err.key}}"] == {{err.value}}) {
            {{err.code}}
        }
        {%endfor%}
        return obj["{{acc.key}}"];
    }
    {% endfor-%}
    {%endif%}
    {%-endif %}
    return {{ met.default }};
}
{%endfor%}

namespace sml = boost::sml;

namespace {

    {% for eve in events.values() %}
    struct {{eve.name}} {
        {% for attr in eve.attrs %}
        {{attr.type.c}} {{attr.name}} = {{attr.def if attr.def != "null"}};
        {% endfor %}
    };
    {% endfor %}

    struct {{smcontext}} {

        // guards
        {% for eg in eve_grds -%}
        virtual bool {{eg[1]}}(const {{eg[0]}}& event) == 0;
        {%- endfor %}

        // actions
        {% for ea in eve_acts -%}
        virtual void {{ea[1]}}(const {{ea[0]}}& event) == 0;
        {%- endfor %}
    };

    {% for mac in machines %}
    struct {{mac.name}} {
        auto operator()() const noexcept {
            using namespace sml;

            {% for eg in eve_grds %}
            const auto {{eg[1]}} = []({{smcontext}}& dep, const auto& ev) {
                return dep.{{eg[1]}}(ev);
            }
            {% endfor %}

            {% for ea in eve_acts %}
            const auto {{ea[1]}} = []({{smcontext}}& dep, const auto& ev) {
                dep.{{ea[1]}}(ev);
            }
            {% endfor %}

            // clang-format off
            return make_transition_table(
{%- for t in mac.tt %}
{{ "," if not loop.first }}{{t.star}} state<{{t.ini}}> + event<{{t.eve.name}}> [ {{ t.grds|join(" and ") }} ] / ( {{ t.acts|join(", ") }} ) = state<{{ t.fin }}>
{%- endfor %}
                );
            // clang-format on
    };
    {% endfor %}

}


#endif // {{namespace|upper}}_{{classname|upper}}_HPP_SEEN
