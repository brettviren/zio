@startuml

[*] --> CTOR
CTOR --> IDLE
IDLE --> BOTSEND : SendMsg [check_send_bot] / send_msg
IDLE --> BOTRECV : RecvMsg [check_recv_bot] / recv_bot
BOTSEND --> flowsm_flowing : RecvMsg [check_recv_bot] / recv_bot
BOTRECV --> flowsm_flowing : SendMsg [check_send_bot] / send_msg
flowsm_flowing --> ACKFIN : SendMsg [check_eot] / send_msg
flowsm_flowing --> FINACK : RecvMsg [check_eot] / recv_msg
FINACK --> FIN : SendMsg [check_eot] / send_msg
ACKFIN --> FIN : RecvMsg [check_eot] / recv_msg


state flowsm_flowing {
[*] --> READY
READY --> flowsm_giving : BeginFlow [lambda(auto:8, FlowApp&)]
READY --> flowsm_taking : BeginFlow [lambda(auto:8, FlowApp&)]


state flowsm_giving {
[*] --> BROKE
BROKE --> GENEROUS : RecvMsg [check_pay] / recv_pay
GENEROUS --> BROKE : SendMsg [check_one_credit, check_dat] / send_msg
GENEROUS --> GENEROUS : SendMsg [check_many_credit, check_dat] / send_msg
GENEROUS --> GENEROUS : RecvMsg [check_pay] / recv_pay
}

state flowsm_taking {
[*] --> RICH
RICH --> HANDSOUT : FlushPay [have_credit] / flush_pay
HANDSOUT --> RICH : RecvMsg [penultimate_credit, check_dat] / recv_msg
HANDSOUT --> HANDSOUT : RecvMsg [!penultimate_credit, check_dat] / recv_msg
HANDSOUT --> HANDSOUT : FlushPay [have_credit] / flush_pay
}

}

@enduml

